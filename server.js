require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { db, plans, orders, documents, sections } = require('./db');
const { eq } = require('drizzle-orm');
const { v4: uuidv4 } = require('uuid');

const generateWord = require('./services/word');
const generatePromptForm1 = require('./services/tilda/promptForm1');
const generatePromptForm2 = require('./services/tilda/promptForm2');
const generatePromptForm3 = require('./services/tilda/promptForm3');
const generatePromptForm4 = require('./services/tilda/promptForm4');
const { TILDA_STRUCTURE, systemPromptForm1, systemPromptForm2, sectionTitles} = require('./services/consts');

const YooKassa = require('yookassa');
const {sendToAdminsOnly} = require("./services/mailer");
const {preprocessText, buildPaymentParams} = require("./services/utils");
const { OpenAI } = require('openai')
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  organization: process.env.OPENAI_ORG_ID
})
const yookassa = new YooKassa({
  shopId: process.env.YOOKASSA_SHOP_ID,
  secretKey: process.env.YOOKASSA_SECRET_KEY,
});

const app = express();

app.use(cors({
  origin: 'https://biznesplan.online',
  methods: ['POST'],
  allowedHeaders: ['Content-Type'],
  optionsSuccessStatus: 204
}));
app.use(express.json());


app.post('/tilda-submit', express.urlencoded({ extended: true }), async (req, res) => {
  const data = req.body;
  console.log('üì• –ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ —Ñ–æ—Ä–º—ã –æ—Ç Tilda:', data);

  if (!data.email) {
    console.warn('‚ùå –ù–µ—Ç email –≤ –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º—ã');
    return res.status(400).json({ error: '–ù–µ —É–∫–∞–∑–∞–Ω email' });
  }

  if (!data.source_url) {
    console.warn('‚ùå –ù–µ—Ç source_url –≤ –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º—ã');
    return res.status(400).json({ error: '–ù–µ —É–∫–∞–∑–∞–Ω source_url' });
  }

  if (data.formname !== 'form1' && data.formname !== 'form2' && data.formname !== 'form3' && data.formname !== 'form4') {
    console.warn('‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π formname:', data.formname);
    return res.status(400).json({ error: '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π formname' });
  }

  const orderId = uuidv4();

  console.log('üìù –°–æ–∑–¥–∞—ë–º –∑–∞–∫–∞–∑ —Å ID:', orderId);

  await db.insert(orders).values({
    id: orderId,
    email: data.email,
    form_type: data.formname,
    form_data: data,
    status: 'pending'
  });

  const returnUrl = data.source_url || 'https://biznesplan.online';

  try {
    const amount = data.price;
    console.log('üí≥ –°—É–º–º–∞ –ø–ª–∞—Ç–µ–∂–∞:', amount);

    const paymentPayload = buildPaymentParams({ amount, returnUrl, email: data.email, orderId });
    const payment = await yookassa.createPayment(paymentPayload, orderId);

    console.log('‚úÖ –ü–ª–∞—Ç—ë–∂ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω:', payment.id);

    await db.update(orders).set({
      yookassa_payment_id: payment.id,
      yookassa_status: payment.status
    }).where(eq(orders.id, orderId));

    startSectionGenerationForMultipleDocs({ orderId, email: data.email, data }).catch(console.error);

    return res.json({ confirmation_url: payment.confirmation.confirmation_url });

  } catch (err) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ–ø–ª–∞—Ç—ã –∏–ª–∏ –∑–∞–ø–∏—Å–∏ –∑–∞–∫–∞–∑–∞:', err);
    await db.update(orders).set({ status: 'error' }).where(eq(orders.id, orderId));
    return res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});


async function startSectionGenerationForMultipleDocs({ orderId, email, data }) {
  let prompts;

  switch (data.formname) {
    case 'form1':
      prompts = [generatePromptForm1(data)];
      break;

    case 'form2':
      prompts = await generatePromptForm2(data);
      break;

    case 'form3':
      prompts = [generatePromptForm3(data)];
      break;

    case 'form4':
      prompts = await generatePromptForm4(data);
      break;

    default:
      throw new Error(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –∏–º—è —Ñ–æ—Ä–º—ã: ${data.formname}`);
  }

  for (let i = 0; i < prompts.length; i++) {
    const prompt = prompts[i];
    const documentId = uuidv4();

    await db.insert(documents).values({
      id: documentId,
      order_id: orderId,
      gpt_prompt: prompt,
      doc_type: 'business_plan',
      status: 'pending'
    });

    await startSectionGeneration({
      documentId,
      basePrompt: prompt,
      systemPrompt: systemPromptForm1
    });
  }

  const docsArray = await db.select().from(documents).where(eq(documents.order_id, orderId));
  if (docsArray.length && docsArray.every(doc => doc.status === 'completed')) {
    await db.update(orders).set({ status: 'completed', updated_at: new Date() }).where(eq(orders.id, orderId));
    console.log(`üì¶ –í—Å–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã. –°—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞ ${orderId} ‚Üí 'completed'`);
    const buffers = await generateTildaBuffers(orderId);
    console.log('üì® –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ –±–∏–∑–Ω–µ—Å-–ø–ª–∞–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º...');
    await sendToAdminsOnly(buffers, email);
    console.log('‚úÖ –í—Å–µ –ø–ª–∞–Ω—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º');
  }
}

async function startSectionGeneration({ documentId, basePrompt, systemPrompt }) {
  const sectionsToInsert = sectionTitles.map((s, idx) => {
    const prompt = idx === 0
      ? `${basePrompt}\n\n‚úèÔ∏è –ù–∞–ø–∏—à–∏ —Ç–æ–ª—å–∫–æ —Ä–∞–∑–¥–µ–ª ${idx + 1} **¬´${s.title}¬ª** (–æ–±—ä–µ–º: –æ–∫–æ–ª–æ ${s.target_word_count} —Å–ª–æ–≤), –Ω–∞—á–Ω–∏ —Å–≤–æ–π –æ—Ç–≤–µ—Ç —Å # ${idx + 1}. ${s.title}`
      : `‚úèÔ∏è –ù–∞–ø–∏—à–∏ —Ç–æ–ª—å–∫–æ —Ä–∞–∑–¥–µ–ª ${idx + 1} **¬´${s.title}¬ª** (–æ–±—ä–µ–º: –æ–∫–æ–ª–æ ${s.target_word_count} —Å–ª–æ–≤).`;

    return {
      id: uuidv4(),
      document_id: documentId,
      index: idx + 1,
      title: s.title,
      prompt,
      status: 'pending'
    };
  });

  await db.insert(sections).values(sectionsToInsert);

  const messages = [{ role: 'system', content: systemPrompt }];

  for (const section of sectionsToInsert) {
    try {
      await delay(5000)
      messages.push({ role: 'user', content: section.prompt });
      const result = await safeGptCall({ messages, max_tokens: 8192 });

      const response = result.choices?.[0]?.message?.content || '–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏';
      const wordCount = response.split(/\s+/).filter(Boolean).length;

      messages.push({ role: 'assistant', content: response });

      await db.update(sections).set({
        gpt_response: response,
        word_count: wordCount,
        status: 'completed',
        updated_at: new Date()
      }).where(eq(sections.id, section.id));

      console.log(`‚úÖ –†–∞–∑–¥–µ–ª ${section.index}: "${section.title}" (${wordCount} —Å–ª–æ–≤)`);

    } catch (err) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–∞–∑–¥–µ–ª–∞ "${section.title}":`, err);
      await db.update(sections).set({
        status: 'error',
        updated_at: new Date()
      }).where(eq(sections.id, section.id));
      return;
    }
  }

  // –°–±–æ—Ä–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞
  const readySections = await db.select().from(sections)
    .where(eq(sections.document_id, documentId))
    .orderBy(sections.index);

  const fullText = readySections
    .map(s => s.gpt_response)
    .join('\n\n');

  await db.update(documents).set({
    gpt_response: fullText,
    status: 'completed',
    updated_at: new Date()
  }).where(eq(documents.id, documentId));
}

async function safeGptCall({ messages, max_tokens = 8192, temperature = 0.7 }) {
  let retries = 5;

  for (let i = 0; i < retries; i++) {
    try {
      const response = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages,
        temperature,
        max_tokens
      });

      return response;
    } catch (err) {
      if (err.code === 'rate_limit_exceeded') {
        const retryAfter = err.headers?.['retry-after'] || 30;
        const waitTime = Number(retryAfter) * 1000;
        console.warn(`üö¶ Rate limit. –ñ–¥—ë–º ${waitTime / 1000} —Å–µ–∫...`);
        await delay(waitTime);
      } else {
        throw err; // –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ –Ω–µ —Å–≤—è–∑–∞–Ω–∞ —Å –ª–∏–º–∏—Ç–æ–º ‚Äî –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º
      }
    }
  }

  throw new Error('üí• –ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –∑–∞–ø—Ä–æ—Å–∞ –∫ GPT (rate limit)');
}

async function generateTildaBuffers(orderId) {
  const docs = await db.select().from(documents).where(eq(documents.order_id, orderId));
  const buffers = await Promise.all(
    docs
      .filter(doc => doc.status === 'completed' && doc.gpt_response)
      .map(async doc => {
        const clean = preprocessText(doc.gpt_response);
        return await generateWord(clean, null, TILDA_STRUCTURE);
      })
  );

  if (buffers.length === 0) {
    console.warn(`‚ö†Ô∏è –ù–µ—Ç –≥–æ—Ç–æ–≤—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ generateTildaBuffers –¥–ª—è orderId: ${orderId}`);
  }

  return buffers;
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

const PORT = process.env.PORT || 3003;
app.listen(PORT, () => console.log(`üöÄ Server on port ${PORT}`));
